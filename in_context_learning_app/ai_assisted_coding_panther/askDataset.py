# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_askDataset.ipynb.

# %% auto 0
__all__ = ['AskDataset']

# %% ../nbs/01_askDataset.ipynb 1
import requests
import openai
from openai import OpenAI
import pandas as pd

# %% ../nbs/01_askDataset.ipynb 2
class AskDataset:
    def __init__(self, data_file):
        try:
            # Attempt to read the uploaded file
            data_csv = pd.read_csv(data_file)
            self.data_csv = data_csv  # Store the DataFrame for later use
        except Exception as e:
            # Provide detailed error information
            raise Exception(f"Failed to initialize AskDataset with file: {data_file}. Error: {e}")

    def dataset_string(self):
        # Convert the DataFrame to a string and return
        return self.data_csv.to_string(index=False)

    def ask_chatgpt(self, question):
        try:
            # Set your OpenAI API key
           

            # API endpoint for ChatGPT
            url = "https://api.openai.com/v1/chat/completions"

            # Headers including the Authorization with your API key
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {openai_api_key}"
            }

            # Data payload for the request
            data_payload = {
                "model": "gpt-3.5-turbo",
                "messages": [
                    {"role": "system", "content": "You are a problem solver. Go through the dataset to find the answer."},
                    {"role": "user", "content": f"Based on {self.dataset_string()} solve the Question: {question}"}
                ]
            }

            response = requests.post(url, headers=headers, json=data_payload, timeout=10)
            response.raise_for_status()

            response_json = response.json()

            if 'choices' in response_json and response_json['choices']:
                message = response_json['choices'][0]['message']
                if isinstance(message, str):
                    return message.strip()
                elif isinstance(message, dict) and 'content' in message:
                    # Extracting content if the message is a dictionary
                    return message['content'].strip()
                else:
                    return "Received unexpected response type: " + str(message)
            else:
                return "No choices in response or empty response: " + str(response_json)

        except requests.exceptions.Timeout:
            return "Request timed out. Please try again."
        except requests.exceptions.HTTPError as err:
            return f"HTTP error occurred: {err}"
        except Exception as e:
            return f"An unexpected error occurred: {e}"
        




